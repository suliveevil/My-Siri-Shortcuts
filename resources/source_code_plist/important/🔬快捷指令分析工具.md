# ğŸ”¬å¿«æ·æŒ‡ä»¤åˆ†æå·¥å…·.shortcut

## å¿«æ·æŒ‡ä»¤ä¿¡æ¯

å¿«æ·æŒ‡ä»¤ï¼šğŸ”¬å¿«æ·æŒ‡ä»¤åˆ†æå·¥å…·
åŠ¨ä½œæ•°é‡ï¼š125
æ–‡ä»¶å¤§å°ï¼š282 KB

Glyph ç¼–å· : 59771
Glyph é¢œè‰² : 463140863

å¿«æ·æŒ‡ä»¤ç±»å‹ : 

WatchKit
ActionExtension

## ä¾èµ– :

- 
- 
- ğŸ”¬å¿«æ·æŒ‡ä»¤åˆ†æå·¥å…·

## URLs :



## åŠ¨ä½œåˆ—è¡¨ : 

```
1: è¯å…¸
2: è®¾å®šå˜é‡ (sc)
3: è®¾å®šå˜é‡ (action_names)
4: è®¾å®šå˜é‡ (action_paras)
5: è®¾å®šå˜é‡ (var_ahead)
6: è®¾å®šå˜é‡ (var_behind)
7: è·å–è®¾å¤‡çš„è¯¦ç»†ä¿¡æ¯ (Device Model)
8: è®¾å®šå˜é‡ (device)
9: è®¡æ•°
10: å¦‚æœ (4 )
11: ä»èœå•ä¸­é€‰å–
12 (11, ): ä»èœå•ä¸­é€‰å– (âœ³ï¸é€‰æ‹©å¿«æ·æŒ‡ä»¤)
13: è·å–æˆ‘çš„å¿«æ·æŒ‡ä»¤
14: ä»åˆ—è¡¨ä¸­é€‰å– (Q: "é€‰æ‹©è¦åˆ†æçš„å¿«æ·æŒ‡ä»¤", Select One)
15: è®¾å®šå˜é‡ (file)
16 (11, ): ä»èœå•ä¸­é€‰å– (ğŸ“ƒé€‰æ‹©æ–‡ä»¶)
17: è·å–æ–‡ä»¶
18: è®¾å®šå˜é‡ (file)
19 (11, ): ä»èœå•ä¸­é€‰å–
20 (10, 4 ): å¦‚æœ
21: è®¾å®šå˜é‡ (file)
22 (10, 4 ): å¦‚æœ
23: è·å–æ–‡ä»¶çš„è¯¦ç»†ä¿¡æ¯ (File Size)
24: è®¾å®šå˜é‡ (file_size)
25: è·å–æ–‡ä»¶çš„è¯¦ç»†ä¿¡æ¯ (Name)
26: è®¾å®šå˜é‡ (sc_name)
27: è·å–æ–‡ä»¶çš„è¯¦ç»†ä¿¡æ¯ (File Extension)
28: è®¾å®šå˜é‡ (file_ext)
29: å¦‚æœ (99 shortcut)
30: ä»è¾“å…¥ä¸­è·å–å›¾åƒ
31: è°ƒæ•´å›¾åƒå¤§å° (100 x Auto)
32: Base64 ç¼–ç 
33: è®¾å®šå˜é‡ (icon_base64)
34: è®¾å®šåç§° (âŠ²**sc_name**âŠ³.plist, without File Extension)
35: è®¾å®šå˜é‡ (file)
36 (29, 99 short...): å¦‚æœ
37 (29, 99 short...): å¦‚æœ
38: ä»è¾“å…¥ä¸­è·å–æ–‡æœ¬
39: è¯å…¸
40: è®¾å®šå˜é‡ (plist_escape)
41: æ–‡æœ¬ (âvar wflowVariableTranslations = {â  "ActionOutput": "OutputName",â  "Ask": "Ask when Run",â  "Clipboard": "Get Clipboard",â  "CurrentDate": "Current Date",â  "ExtensionInput": "Workflow Input",â  "Variable": "VariableName"â};â//function cl(...o) {â  //console.log(JSON.stringify(o, null, 2));â//}âfunction parseFormat(format, params) {â  var res = params[format.condition];â  if (!res)â    return format.empty || format.default;â  res = format.cases[res] || format.default;â  if (typeof res !== "string")â    return parseFormat(res, params);â  return res;â}âfunction getFirstNotNull(ar, def) {â  if (!Array.isArray(ar))â    throw "getFirstNotNull should be called with an array!";â  var l = ar.length;â  if (l < 1)â    throw "getFirstNotNull should be called with an array with at least one element!";â  for (var i = 0; i < l; i++)â    if ("undefined" !== typeof ar[i])âreturn ar[i];â  return "undefined" !== typeof def ? def : ar[l - 1];â}âfunction getAggrandizement(o) {â  //cl("aggrandizement", o);â  if (!o || !o.Aggrandizements || !o.Aggrandizements.length) {â    return "";â  }â  var agg = o.Aggrandizements;â  for (var i = 0; i < agg.length; i++)â  if (agg[i].Type === "WFPropertyVariableAggrandizement")â    return "|" + agg[i].PropertyName;â  else if(agg[i].Type === "WFDictionaryValueVariableAggrandizement")â    return "|" + agg[i].DictionaryKey;â  â  //cl(agg);â  return "";â}âfunction getWflowVariableName(dict) {â  return "undefined" !== typeof dict["Type"] ? variableOpeningChar +  getFirstNotNull([ dict[wflowVariableTranslations[dict["Type"]]], wflowVariableTranslations[dict["Type"]], dict["Type"] ]) + getAggrandizement(dict) + variableClosingChar : dict;â}âfunction roundNumber(num, scale) {â  if(!("" + num).includes("e")) {â    return +(Math.round(num + "e+" + scale) + "e-" + scale);â  } else {â    var arr = ("" + num).split("e");â    var sig = "";â    if(+arr[1] + scale > 0) {â      sig = "+";â    }â    return +(Math.round(+arr[0] + "e" + sig + (+arr[1] + scale)) + "e-" + scale);â  }â}âvar formatRegex = /((?!\\\{)\{(?:\\\}|[^\}])+\}|(?:\\\{|[^\{])+)/g;âvar isNumRegex = /^\s*-?[0-9]+(?:[.,][0-9]+)?\s*$/;âvar getIndexFromRangeRegex = /^\{(\d+), \d+\}$/;âvar maxCodeBlockContentLength = deviceModel === "iPad" ? 30 : 10;âtry {â  wflow = PlistParser.parse(wflow.g);â  wflow = JSON.parse(JSON.stringify(wflow, null, 0), function (k, v) { return typeof v === "number" || typeof v === "date" ? v.toString() : typeof v === "boolean" ? v ? "1" : "0" : v; });â  var result = [],â      codeBlocks = [],â      codeBlocksId = {â   "is.workflow.actions.conditional": true,â   "is.workflow.actions.repeat.count": true,â   "is.workflow.actions.repeat.each": true,â "is.workflow.actions.choosefrommenu": trueâ};â  var actionIndex = 0, codeBlock = "";â  wflow.WFWorkflowActionsâ    .forEach(function(action) {â    actionIndex++;â    codeBlock = "";â    var content = "";â    var id = action.WFWorkflowActionIdentifier;â    var name = getFirstNotNull([actionNamesTranslation[id], id]);â    var paramsFromWflow = action.WFWorkflowActionParameters;â    var paramsToExtract = allActionParams[id];â    var parsedFormat = "";â    if (typeof paramsToExtract !== "undefined") {â      var format = paramsToExtract.format;â      format = (typeof format !== "string") ? parseFormat(format, paramsFromWflow) : format;â      var match;â      var nVars = 0, failed = 0;â      while ((match = formatRegex.exec(format)) != null) {â        if (match[0].startsWith("{")) {â          nVars++;â          var variable = match[0].substring(1, match[0].length - 1);â          var list = [];â          var parts = variable.split("|");â          for (var i = 0; i < parts.length; i++)â            if (typeof paramsFromWflow[parts[i].split(":")[0]] !== "undefined")â              list.push(parts[i]);â          variable = (list.length > 0 ? list[0] : variable.split("|")[0]);â          var comma = variable.split(":").length > 1 ? variable.split(":")[1] : 3;â          variable = variable.split(":")[0];â          content = paramsFromWflow[variable] || paramsToExtract.empty && paramsToExtract.empty[variable];â          if (typeof content === "undefined") failed++;â          if (isNumRegex.test(content)) content = roundNumber(content, comma).toString();â          content = (paramsToExtract.replace && paramsToExtract.replace[variable] && paramsToExtract.replace[variable][content]) || content;â          //cl(actionIndex, content);â          if (typeof content === "object") {â            // (magic) variables are usedâ            switch (content.WFSerializationType) {â            case "WFTextTokenAttachment":â              content = getWflowVariableName(content.Value);â              break;â            case "WFTextTokenString":â              list = content.Value.string.split("");â              var keyList = [];â              var abr = content.Value.attachmentsByRange;â              Object.keys(abr)â                .forEach(function (k) { keyList[parseInt(getIndexFromRangeRegex.exec(k)[1])] = getWflowVariableName(abr[k]); });â              if (content.Value.string.includes("\ufffc")) {â                content = "";â                for (var i = 0; i < list.length; i++) {â                  var n = list[i];â                  if (n === "\ufffc") {â                    while (typeof (n = keyList.shift()) === "undefined" && keyList.length > 0) ;â                  }â                  content += n;â                }â              } else {â                for (var i = 0; i < keyList.length; i++)â                  if (keyList[i])â                    list.splice(i, 0, keyList[i]);â                content = list.join("");â              }â              break;â            case "WFTimeOffsetValue":â              content = content.Value;â              content = content.Operation.replace("Add", "+").replace("Subtract", "-") + " " + getWflowVariableName(content.Value) + " " + content.Unit + (parseFloat(content.Value) != 1 ? "s" : "");â              break;â            case "WFContentPredicateTableTemplate":â            case "WFContactFieldValue":â            case "WFQuantityFieldValue":â              failed++;â              break;â            default:â              failed++;â              break;â            }â          }â          parsedFormat += content || "";â        } elseâ          parsedFormat += match[0];â      }â    }â    // format doneâ    // save "code blocks" (if, repeat, repeat with each, choose from menu)â    codeBlock = "";â    if (codeBlocksId[id]) {â      var mode = paramsFromWflow.WFControlFlowMode;â      if (Array.isArray(name))â        name = name[mode];â      if (mode == 0) {â        codeBlocks.push(actionIndex + ", " + (parsedFormat.length > maxCodeBlockContentLength ? parsedFormat.substr(0, maxCodeBlockContentLength - 2) + "..." : parsedFormat));â      } else {â        codeBlock = " (" + codeBlocks[codeBlocks.length - 1] + ")";â        if (mode == 2)â          codeBlocks.pop();â      }â    }â    result.push(actionIndex + codeBlock + ": " + name + (parsedFormat && parsedFormat.length > 0 && failed < nVars ? " (" + parsedFormat.replace(/[\r\n]+/g, "â") + ")": ""));â  });â  result = { list: result };â  document.body.appendChild(document.createTextNode(JSON.stringify(result, null, 4)));â} catch (ex) {â  document.body.appendChild(document.createTextNode(JSON.stringify({ type: ex.name, msg: ex.message, line: ex.line, column: ex.column, sourceURL: ex.sourceURL}, null, 0)));â  throw ex;â})
42: è®¾å®šå˜é‡ (script)
43: æ–‡æœ¬ (/**â PlistParser: a JavaScript utility to process Plist XML into JSONâ @author Todd Gehman (toddgehman@gmail.com)â Copyright (c) 2010 Todd Gehmanâ --- â Usage:â   var jsonString = PlistParser.parse(xmlString);â ---â âPermission is hereby granted, free of charge, to any person obtaining a copyâof this software and associated documentation files (the "Software"), to dealâin the Software without restriction, including without limitation the rightsâto use, copy, modify, merge, publish, distribute, sublicense, and/or sellâcopies of the Software, and to permit persons to whom the Software isâfurnished to do so, subject to the following conditions:âThe above copyright notice and this permission notice shall be included inâall copies or substantial portions of the Software.âTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORâIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,âFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEâAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERâLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,âOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INâTHE SOFTWARE.â*/âvar PlistParser = {};âPlistParser.parse = function(plist_xml){â  // Special case XML munging if we're running in Appcelerator Titaniumâ  try{â    if (typeof Titanium.XML != 'undefined'){â      plist_xml = Titanium.XML.parseString(plist_xml);â    }â  } catch(e){â    var parser = new DOMParser();â		  plist_xml = parser.parseFromString(plist_xml, 'text/xml');â  }â    â  var result = this._xml_to_json(plist_xml.getElementsByTagName('plist').item(0));â  return result;â};âPlistParser._xml_to_json = function(xml_node) {â  var parser = this;â  var parent_node = xml_node;â  var parent_node_name = parent_node.nodeName;â  // console.log("Working on parent node: ");â  // console.log(parent_node);â  var child_nodes = [];â  for(var i = 0; i < parent_node.childNodes.length; ++i){â    var child = parent_node.childNodes.item(i);â    if (child.nodeName != '#text'){â      child_nodes.push(child);â    };â  };â  â  switch(parent_node_name){â    case 'plist':â      if (child_nodes.length > 1){â        // I'm not actually sure if it is legal to have multipleâ        // top-level nodes just below <plist>. But I originally â        // wrote it to handle an array of nodes at that level,â        // so I'm leaving this handling in for now.â        var plist_array = [];â        for(var i = 0; i < child_nodes.length; ++i){â           plist_array.push(parser._xml_to_json(child_nodes[i]));â        };â        // var plist_hash = {};â        // plist_hash['plist'] = plist_array;â        // return plist_hash;â        return plist_array;â      } else {â        // THIS is the standard case. The top-most node underâ        // <plist> is either a <dict> or an <array>.â        return parser._xml_to_json(child_nodes[0]);â      }â      break;â    case 'dict':â      var dictionary = {};â      var key_name;â      var key_value;â      for(var i = 0; i < child_nodes.length; ++i){â        var child = child_nodes[i];â        if (child.nodeName == '#text'){â          // ignore empty text childrenâ        } else if (child.nodeName == 'key'){â          key_name = PlistParser._textValue(child.firstChild);â        } else {â          key_value = parser._xml_to_json(child);â          dictionary[key_name] = key_value;â        }â      }â      return dictionary;â    case 'array':â      var standard_array = [];â      for(var i = 0; i < child_nodes.length; ++i){â        var child = child_nodes[i];â        standard_array.push(parser._xml_to_json(child));â      }â      return standard_array;â    case 'string':â      return PlistParser._textValue(parent_node);â    case 'date':â      var date = PlistParser._parseDate(PlistParser._textValue(parent_node));â      return date.toString();â    case 'integer':â    â      // Second argument (radix parameter) forces string to be interpreted in base 10.â      return parseInt(PlistParser._textValue(parent_node), 10);â    case 'real':â    â      return parseFloat(PlistParser._textValue(parent_node));â    case 'data':â      return PlistParser._textValue(parent_node);â    case 'true':â      return true;â    case 'false':â    â      return false;â      â    â    case '#text':â      break;â  };â};âPlistParser._textValue = function(node) {â  if (node.text){â    return node.text;â  } else {â    return node.textContent;â  };â};â// Handle date parsing in non-FF browsersâ// Thanks to http://www.west-wind.com/weblog/posts/729630.aspxâPlistParser._parseDate = function(date_string){â  var reISO = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;â  var matched_date = reISO.exec(date_string);â  if (matched_date){ â    return new Date(Date.UTC(+matched_date[1], +matched_date[2] - 1, +matched_date[3], +matched_date[4], +matched_date[5], +matched_date[6]));â  };â};â// Lifted (then modified) from: â// http://blog.stchur.com/2007/04/06/serializing-objects-in-javascript/âPlistParser.serialize = function(_obj) {â  // Let Gecko browsers do this the easy wayâ  try{â    if (typeof _obj.toSource !== 'undefined' && typeof _obj.callee === 'undefined') {â      return _obj.toSource();â    }â  } catch(e) {â    // Keep on truckin'.â  }â  // Other browsers must do it the hard wayâ  switch (typeof _obj)â  {â    // numbers, booleans, and functions are trivial:â    // just return the object itself since its default .toString()â    // gives us exactly what we wantâ    case 'number':â    case 'boolean':â    case 'function':â      return _obj;â    // for JSON format, strings need to be wrapped in quotesâ    case 'string':â      return '\'' + _obj + '\'';â    case 'object':â      var str;â      if (_obj.constructor === Array || typeof _obj.callee !== 'undefined')â      {â        str = '[';â        var i, len = _obj.length;â        for (i = 0; i < len-1; i++) { str += PlistParser.serialize(_obj[i]) + ','; }â        str += PlistParser.serialize(_obj[i]) + ']';â      }â      elseâ      {â        str = '{';â        var key;â        for (key in _obj) { â          // "The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype."â          if (_obj.hasOwnProperty(key)) {â            str += key + ':' + PlistParser.serialize(_obj[key]) + ','; â          };â        };â        str = str.replace(/\,$/, '') + '}';â      }â      return str;â    default:â      return 'UNKNOWN';â  };â};âPlistParser.toPlist = function(obj){â  var xml = '<?xml version="1.0" encoding="UTF-8"?>';â  xml += '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">';â  var container = document.createElement('xml');â  var plist = document.createElement('plist');â  plist.setAttribute('version','1.0');â  container.appendChild(plist);â  â  var root = document.createElement('dict');â  plist.appendChild(root);â  var getISOString = function(date){â    function pad(n) { return n < 10 ? '0' + n : n }â    return date.getUTCFullYear() + '-'â      + pad(date.getUTCMonth() + 1) + '-'â      + pad(date.getUTCDate()) + 'T'â      + pad(date.getUTCHours()) + ':'â      + pad(date.getUTCMinutes()) + ':'â      + pad(date.getUTCSeconds()) + 'Z';â  }â  var walkObj = function(target, obj, callback){â    for(var i in obj){â      callback(target, i, obj[i]);â    }â  }â  var processObject = function(target, name, value){â    var key = document.createElement('key');â    key.innerHTML = name;â    target.appendChild(key);â    if(typeof value == 'object'){â      if(value instanceof Date){â        var date = document.createElement('date');â        date.innerHTML = getISOString(value);â        target.appendChild(date);â      }else{â        var dict = document.createElement('dict');â        walkObj(dict, value, processObject)â        target.appendChild(dict);â      }â    }else if(typeof value == 'boolean'){â      var bool = document.createElement(value.toString());â      target.appendChild(bool);â    }else{â      var string = document.createElement('string');â      string.innerHTML = value;â      target.appendChild(string);â    }â  };â  walkObj(root, obj, processObject);â  return xml+container.innerHTML;â};â)
44: è®¾å®šå˜é‡ (plistparser)
45: æ–‡æœ¬ (<html>â<head>â<meta charset="utf-8">â<meta name="viewport" content="initial-scale=1, width=device-width">â<style>âbody {âfont-family: monospace;âwhite-space: pre;â}â</style>â</head>â<body>â<script>ââŠ²**plistparser**âŠ³âvar wflow = âŠ²**plist_escape**âŠ³;âvar actionNamesTranslation = âŠ²**action_names**âŠ³;âvar allActionParams = âŠ²**action_paras**âŠ³;âvar variableOpeningChar = "âŠ²**var_ahead**âŠ³", variableClosingChar = "âŠ²**var_behind**âŠ³";âvar deviceModel = "device";ââŠ²**script**âŠ³â</script>â</body>â</html>)
46: è®¾å®šåç§° (action_list.html, with File Extension)
47: Base64 ç¼–ç 
48: URL (data:text/html;base64,âŠ²**Base64 Encoded**âŠ³)
49: è·å–ç½‘é¡µå†…å®¹
50: ä»è¾“å…¥ä¸­è·å–æ–‡æœ¬
51: ä»è¾“å…¥ä¸­è·å–è¯å…¸
52: è·å–è¯å…¸å€¼ (Key: list)
53: åˆå¹¶æ–‡æœ¬
54: è®¾å®šå˜é‡ (action_list)
55: ä»è¾“å…¥ä¸­è·å–è¯å…¸
56: è®¾å®šå˜é‡ (dict)
57: è·å–è¯å…¸å€¼ (Key: WFActionTypes)
58: ä¸ºæ¯ä¸ªé¡¹ç›®é‡å¤
59: æ–‡æœ¬ (- âŠ²**Repeat Item**âŠ³)
60: æ·»åŠ åˆ°å˜é‡ (ActionTypes)
61 (58, ): ä¸ºæ¯ä¸ªé¡¹ç›®é‡å¤
62: è·å–è¯å…¸å€¼ (Key: WFWorkflowIcon)
63: è·å–è¯å…¸å€¼ (Key: WFWorkflowIconGlyphNumber)
64: è·å–è¯å…¸å€¼ (Key: WFWorkflowIcon)
65: è·å–è¯å…¸å€¼ (Key: WFWorkflowIconStartColor)
66: è·å–è¯å…¸å€¼ (Key: WFWorkflowTypes)
67: è·å–è¯å…¸å€¼ (Key: WFWorkflowInputContentItemClasses)
68: ä¸ºæ¯ä¸ªé¡¹ç›®é‡å¤
69: æ–‡æœ¬ (âŠ²**Repeat Item**âŠ³)
70: æ›¿æ¢æ–‡æœ¬ (Replace WF with , Regex: No, Case Sensitive: Yes)
71: æ›¿æ¢æ–‡æœ¬ (Replace ContentItem with  , Regex: No, Case Sensitive: Yes)
72: æ·»åŠ åˆ°å˜é‡ (Classes)
73 (68, ): ä¸ºæ¯ä¸ªé¡¹ç›®é‡å¤
74: åˆå¹¶æ–‡æœ¬ (Separator: ",")
75: è®¾å®šå˜é‡ (Classes)
76: è·å–è¯å…¸å€¼ (Key: WFWorkflowActions)
77: è®¡æ•° (Items)
78: è·å–è¯å…¸å€¼ (Key: WFWorkflowActions)
79: ä¸ºæ¯ä¸ªé¡¹ç›®é‡å¤
80: å¦‚æœ (99 is.workflow.actions.runworkflow)
81: è·å–è¯å…¸å€¼ (Key: WFWorkflowActionParameters)
82: è·å–è¯å…¸å€¼ (Key: WFWorkflowName)
83: æ–‡æœ¬ (- âŠ²**Dictionary Value**âŠ³)
84: æ·»åŠ åˆ°å˜é‡ (Dependencies)
85 (80, 99 is.wo...): å¦‚æœ
86: å¦‚æœ (99 is.workflow.actions.comment)
87: è·å–è¯å…¸å€¼ (Key: WFWorkflowActionParameters)
88: è·å–è¯å…¸å€¼ (Key: WFCommentActionText)
89: æ–‡æœ¬ (- âŠ²**Dictionary Value**âŠ³)
90: æ·»åŠ åˆ°å˜é‡ (Comments)
91 (86, 99 is.wo...): å¦‚æœ
92 (86, 99 is.wo...): å¦‚æœ
93 (80, 99 is.wo...): å¦‚æœ
94 (79, ): ä¸ºæ¯ä¸ªé¡¹ç›®é‡å¤
95: åŒ¹é…æ–‡æœ¬ (Case Sensitive: Yes, Pattern: b(https?|ftp|file)://S+)
96: æ›¿æ¢æ–‡æœ¬ (Replace </string> with , Regex: No, Case Sensitive: Yes)
97: æ›¿æ¢æ–‡æœ¬ (Replace http://www.apple.com/DTDs/PropertyList-1.0.dtd"> with , Regex: No, Case Sensitive: Yes)
98: ä¸ºæ¯ä¸ªé¡¹ç›®é‡å¤
99: æ–‡æœ¬ ( - âŠ²**Repeat Item**âŠ³)
100: æ·»åŠ åˆ°å˜é‡ (Urls)
101 (98, ): ä¸ºæ¯ä¸ªé¡¹ç›®é‡å¤
102: æ–‡æœ¬ (# âŠ²**sc_name**âŠ³.âŠ²**file_ext**âŠ³â## å¿«æ·æŒ‡ä»¤ä¿¡æ¯âå¿«æ·æŒ‡ä»¤ï¼šâŠ²**sc_name**âŠ³âåŠ¨ä½œæ•°é‡ï¼šâŠ²**Count**âŠ³âæ–‡ä»¶å¤§å°ï¼šâŠ²**file_size**âŠ³âGlyph ç¼–å· : âŠ²**Dictionary Value**âŠ³âGlyph é¢œè‰² : âŠ²**Dictionary Value**âŠ³âå¿«æ·æŒ‡ä»¤ç±»å‹ : ââŠ²**Dictionary Value**âŠ³â## ä¾èµ– :ââŠ²**Dependencies**âŠ³â## URLs :ââŠ²**Urls**âŠ³â## åŠ¨ä½œåˆ—è¡¨ : â```ââŠ²**action_list**âŠ³â```â## Content Classes : ââŠ²**Classes**âŠ³â## æ³¨é‡Š:â```ââŠ²**Comments**âŠ³â```)
103: è®¾å®šå˜é‡ (result)
104: ä» Markdown åˆ¶ä½œå¤šä¿¡æ¯æ–‡æœ¬
105: ç”¨å¤šä¿¡æ¯æ–‡æœ¬åˆ¶ä½œ HTML
106: å¦‚æœ (99 shortcut)
107: æ–‡æœ¬ (<!DOCTYPE html>â<html>â<head>â<title> âŠ²**sc_name**âŠ³ - ğŸ”¬å¿«æ·æŒ‡ä»¤åˆ†æå·¥å…·</title>â    <meta charset="utf-8" />â    <meta name="viewport" content="width=device-width, initial-scale=1.0" />â    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css">â</head>â<body>â<table style="undefined;table-layout: fixed; width: 700px">â    <colgroup>â        <col style="width: 100px">â        <col style="width:  600px">â    </colgroup>â    <tr>â        <th>â            <h1>â            <img src="data:image/png;base64,âŠ²**Base64å·²ç¼–ç å†…å®¹**âŠ³"/>â            </h1>â        </th>â    </tr>â</table>â<div class="container">â    <p>â    âŠ²**æ¥è‡ªå¤šä¿¡æ¯æ–‡æœ¬çš„HTML**âŠ³â</div>â</body>â</html>)
108 (106, 99 short...): å¦‚æœ
109: æ–‡æœ¬ (<!DOCTYPE html>â<html>â<head>â<title> âŠ²**sc_name**âŠ³ - ğŸ”¬å¿«æ·æŒ‡ä»¤åˆ†æå·¥å…·</title>â    <meta charset="utf-8" />â    <meta name="viewport" content="width=device-width, initial-scale=1.0" />â    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css">â</head>â<body>â<div class="container">â    <p>â    âŠ²**æ¥è‡ªå¤šä¿¡æ¯æ–‡æœ¬çš„HTML**âŠ³â</div>â</body>â</html>)
110 (106, 99 short...): å¦‚æœ
111: è®¾å®šåç§° (âŠ²**sc_name**âŠ³.html, with File Extension)
112: è®¾å®šå˜é‡ (result_html)
113: æ˜¾ç¤ºç½‘é¡µ
114: ä»èœå•ä¸­é€‰å–
115 (114, ): ä»èœå•ä¸­é€‰å– (ä¿å­˜ä¸º HTML)
116: å­˜å‚¨æ–‡ä»¶
117 (114, ): ä»èœå•ä¸­é€‰å– (ä¿å­˜ä¸º Markdown)
118: ä»è¾“å…¥ä¸­è·å–æ–‡æœ¬
119: è®¾å®šåç§° (âŠ²**sc_name**âŠ³.md, without File Extension)
120: å­˜å‚¨æ–‡ä»¶
121 (114, ): ä»èœå•ä¸­é€‰å– (åˆ†æä¸‹ä¸€ä¸ªå¿«æ·æŒ‡ä»¤)
122: è¿è¡Œå¿«æ·æŒ‡ä»¤ (Workflow "ğŸ”¬å¿«æ·æŒ‡ä»¤åˆ†æå·¥å…·", Donâ€™t Show When Run)
123 (114, ): ä»èœå•ä¸­é€‰å– (é€€å‡º)
124: é€€å‡ºå¿«æ·æŒ‡ä»¤
125 (114, ): ä»èœå•ä¸­é€‰å–
```

## Content Classes : 

AppStoreApp ,Article ,Contact ,Date ,EmailAddress ,GenericFile ,Image ,iTunesProduct ,Location ,DCMapsLink ,AVAsset ,PDF ,PhoneNumber ,RichText ,SafariWebPage ,String ,URL 

## æ³¨é‡Š:

```
- 
```